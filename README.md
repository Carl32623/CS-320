Carl LaLonde

Software Test, Automation QA

To ensure that my code was functional, I wrote unit tests that validate features of the code against defined requirements.  I made sure to test both normal and non-normal test cases, checking that all of the rules for validation were enforced.  For security, I made sure that no sensitive information was hardcoded into the program, and user data was handled according to defined requirements.  Regular testing helped reveal any issues early in the development cycle. 

Interpreting the users needs began with analyzing the given requirements and translating those needs into features or constraints within the program.  I broke down each user requirement into tasks, such as making sure that a contacts phone number was exactly 10 digits or making sure that an ID was to be unique and not already in use.  While coding, I consistently returned to the requirements, making sure that the user needs were met accurately and thoroughly.  

When I approach software design, I start by creating a basic structure of the classes making sure that each class has a single and clear purpose.  I then add features and constraints to the code based upon the requirements set before me.  Writing clear and easily testable code helped make the testing process smoother and easier, which has resulted in a higher quality final product.  
